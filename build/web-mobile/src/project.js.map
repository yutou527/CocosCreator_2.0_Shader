{"version":3,"sources":["assets/Script/shader/fluxay/FluxyMaterial.js","assets/Script/shader/fluxay/FluxyShader.js","assets/Script/shader/light/LightMaterial.js","assets/Script/shader/light/LightShader.js","assets/Script/shader/rain/RainMaterial.js","assets/Script/shader/rain/RainShader.js","assets/Script/shader/test/TestMaterial.js","assets/Script/shader/test/TestShader.js","assets/Script/shader/thunder/ThunderMaterial.js","assets/Script/shader/thunder/ThunderShader.js","assets/Script/shader/flux.js","assets/Script/shader/light.js","assets/Script/main.js","assets/Script/shader/rain.js","assets/Script/shader/test/shaping.js","assets/Script/shader/test.js","assets/Script/shader/thunder.js"],"names":["cc","vmath","renderEngine","renderer","gfx","Material","FluxyMaterial","name","call","this","pass","Pass","setDepth","setCullMode","CULL_NONE","setBlend","BLEND_FUNC_ADD","BLEND_SRC_ALPHA","BLEND_ONE_MINUS_SRC_ALPHA","mainTech","Technique","type","PARAM_TEXTURE_2D","PARAM_FLOAT","_texture","_effect","effect","Effect","_mainTech","require","js","extend","mixin","prototype","getTexture","setTexture","val","update","flipY","mipmap","setProperty","getImpl","_texIds","getId","setStrength","s","setTime","time","setRevert","isRevert","module","exports","shader","defines","vert","frag","game","once","EVENT_ENGINE_INITED","_forward","_programLib","define","LightMaterial","math","RainMaterial","PARAM_FLOAT2","PARAM_FLOAT3","_resolution","vec3","create","_texSize","vec2","_time","iResolution","texSize","value","x","width","y","height","setResolution","w","h","setHasHeart","usePostProcessing","TestMaterial","log","setPosition","p","pos","ThunderMaterial","Class","extends","Component","properties","start","_start","Date","now","target","getComponent","Sprite","spriteFrame","texture","_material","updateHash","_renderData","autoStart","_shouldRun","onLoad","dynamicAtlasManager","enabled","dt","from","to","speed","breath","isAnim","delay","doStart","_light","onEnable","_this","_isRunning","_direction","_from","_to","unscheduleAllCallbacks","scheduleOnce","_","doPause","doResume","doStop","revert","testNode","Node","active","material","node","on","EventType","MOUSE_MOVE","e","location","convertToNodeSpaceAR","getLocation"],"mappings":"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","sourcesContent":["const math = cc.vmath;\r\nconst renderEngine = cc.renderer.renderEngine;\r\nconst renderer = renderEngine.renderer;\r\nconst gfx = renderEngine.gfx;\r\nconst Material = renderEngine.Material;\r\n\r\n// Require to load the shader to program lib\r\nrequire('./FluxyShader');\r\n\r\nfunction FluxyMaterial(name) {\r\n    Material.call(this, false);\r\n\r\n    var pass = new renderer.Pass('fluxy');\r\n    pass.setDepth(false, false);\r\n    pass.setCullMode(gfx.CULL_NONE);\r\n    pass.setBlend(\r\n        gfx.BLEND_FUNC_ADD,\r\n        gfx.BLEND_SRC_ALPHA, gfx.BLEND_ONE_MINUS_SRC_ALPHA,\r\n        gfx.BLEND_FUNC_ADD,\r\n        gfx.BLEND_SRC_ALPHA, gfx.BLEND_ONE_MINUS_SRC_ALPHA\r\n    );\r\n\r\n    let mainTech = new renderer.Technique(\r\n        ['transparent'],\r\n        [{\r\n            name: 'iTexture',\r\n            type: renderer.PARAM_TEXTURE_2D\r\n        }, {\r\n            name: 'time',\r\n            type: renderer.PARAM_FLOAT\r\n        }],\r\n        [\r\n            pass\r\n        ]\r\n    );\r\n\r\n    this._texture = null;\r\n\r\n    // need _effect to calculate hash\r\n    this._effect = this.effect = new renderer.Effect(\r\n        [\r\n            mainTech,\r\n        ], {},\r\n        []\r\n    );\r\n\r\n    this._mainTech = mainTech;\r\n}\r\ncc.js.extend(FluxyMaterial, Material);\r\ncc.js.mixin(FluxyMaterial.prototype, {\r\n    getTexture() {\r\n        return this._texture;\r\n    },\r\n\r\n    setTexture(val) {\r\n        if (this._texture !== val) {\r\n            this._texture = val;\r\n            this._texture.update({\r\n                // Adapt to shader\r\n                flipY: false,\r\n                // For load texture\r\n                mipmap: false\r\n            });\r\n            this.effect.setProperty('iTexture', val.getImpl());\r\n            this._texIds['iTexture'] = val.getId();\r\n        }\r\n    },\r\n    setStrength(s) {\r\n        this.effect.setProperty('light_strength', s);\r\n    },\r\n    setTime(time) {\r\n        this.effect.setProperty('time', time);\r\n    },\r\n\r\n    setRevert(isRevert) {\r\n        this.effect.setProperty('revert', isRevert);\r\n    },\r\n\r\n});\r\n\r\nmodule.exports = FluxyMaterial;","let shader = {\r\n    name: 'fluxy',\r\n\r\n    defines: [\r\n    ],\r\n    vert: `\r\n    uniform mat4 viewProj;\r\n    attribute vec3 a_position;\r\n    attribute vec2 a_uv0;\r\n    varying vec2 uv0;\r\n    void main() {\r\n        vec4 pos = viewProj * vec4(a_position, 1);\r\n        gl_Position = pos;\r\n        uv0 = a_uv0;\r\n    }`,\r\n\r\n    // frag:\r\n    //     `#define TAU 6.12\r\n    //     #define MAX_ITER 10\r\n    //     uniform sampler2D texture;\r\n    //     uniform vec4 color;\r\n    //     uniform float time;\r\n    //     varying vec2 uv0;\r\n\r\n    //     void main()\r\n    //     {\r\n    //         float time = time * .5+5.;\r\n    //         // uv should be the 0-1 uv of texture...\r\n    //         vec2 uv = uv0.xy;//fragCoord.xy / iResolution.xy;\r\n\r\n    //         vec2 p = mod(uv*TAU, TAU)-250.0;\r\n\r\n    //         vec2 i = vec2(p);\r\n    //         float c = 1.0;\r\n    //         float inten = .0045;\r\n\r\n    //         for (int n = 0; n < MAX_ITER; n++) \r\n    //         {\r\n    //             float t =  time * (1.0 - (3.5 / float(n+1)));\r\n    //             i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(1.5*t + i.x));\r\n    //             c += 1.0/length(vec2(p.x / (cos(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\r\n    //         }\r\n    //         c /= float(MAX_ITER);\r\n    //         c = 1.17-pow(c, 1.4);\r\n    //         vec4 tex = texture2D(texture,uv);\r\n    //         vec3 colour = vec3(pow(abs(c), 20.0));\r\n    //         colour = clamp(colour + vec3(0.0, 0.0, .0), 0.0, tex.a);\r\n\r\n    //         // 混合波光\r\n    //         float alpha = c*tex[3];  \r\n    //         tex[0] = tex[0] + colour[0]*alpha; \r\n    //         tex[1] = tex[1] + colour[1]*alpha; \r\n    //         tex[2] = tex[2] + colour[2]*alpha; \r\n    //         gl_FragColor = color * tex;\r\n    //     }`,\r\n    frag: `\r\n    uniform float time;\r\n    uniform sampler2D iTexture;\r\n    varying vec2 uv0;\r\n    uniform vec4 color;\r\n\r\n    void main()\r\n    {\r\n       vec4 src_color = color * texture2D(iTexture, uv0).rgba;\r\n\r\n        float w = 0.4;       //宽度\r\n        float start = abs(sin(time/1.414)); //位置函数\r\n        // float start = tan(time/1.414);  \r\n        float strength = 3.0;   //流光增亮强度   (调整该值改变流光的增亮强度)\r\n        float offset = 0.2;      //偏移值         (调整该值改变流光的倾斜程度)\r\n        if(uv0.x < start &&  uv0.x > (start - w))\r\n        // if(uv0.x < (start - offset * uv0.y) &&  uv0.x > (start - offset * uv0.y - w))\r\n        {\r\n            // strength = 1.0 + 2.*(1.-abs(uv0.x - start + w/2.)/(w/2.)); //渐变强度\r\n            strength = 1.0 + 3.*smoothstep(0.0,1.0,1.-abs(uv0.x - start + w/2.)/(w/2.)); //渐变强度 使用smoothstep\r\n            vec3 result = vec3( src_color.r * strength, src_color.g *strength, src_color.b *strength);\r\n            gl_FragColor = vec4(result, src_color.a);\r\n\r\n        }else{\r\n            gl_FragColor = src_color;\r\n        }\r\n    }`,\r\n    //gl_FragColor = vec4(result, src_color.a);\r\n    //gl_FragColor = revert?src_color:vec4(result, src_color.a);\r\n};\r\n\r\ncc.game.once(cc.game.EVENT_ENGINE_INITED, function () {\r\n    cc.renderer._forward._programLib.define(shader.name, shader.vert, shader.frag, shader.defines);\r\n});\r\n\r\nmodule.exports = shader;","const math = cc.vmath;\r\nconst renderEngine = cc.renderer.renderEngine;\r\nconst renderer = renderEngine.renderer;\r\nconst gfx = renderEngine.gfx;\r\nconst Material = renderEngine.Material;\r\n\r\n// Require to load the shader to program lib\r\nrequire('./LightShader');\r\n\r\nfunction LightMaterial(name) {\r\n    Material.call(this, false);\r\n\r\n    var pass = new renderer.Pass('light');\r\n    pass.setDepth(false, false);\r\n    pass.setCullMode(gfx.CULL_NONE);\r\n    pass.setBlend(\r\n        gfx.BLEND_FUNC_ADD,\r\n        gfx.BLEND_SRC_ALPHA, gfx.BLEND_ONE_MINUS_SRC_ALPHA,\r\n        gfx.BLEND_FUNC_ADD,\r\n        gfx.BLEND_SRC_ALPHA, gfx.BLEND_ONE_MINUS_SRC_ALPHA\r\n    );\r\n\r\n    let mainTech = new renderer.Technique(\r\n        ['transparent'],\r\n        [{\r\n            name: 'iTexture',\r\n            type: renderer.PARAM_TEXTURE_2D\r\n        }, {\r\n            name: 'light_strength',\r\n            type: renderer.PARAM_FLOAT\r\n        }],\r\n        [\r\n            pass\r\n        ]\r\n    );\r\n\r\n    this._texture = null;\r\n\r\n    // need _effect to calculate hash\r\n    this._effect = this.effect = new renderer.Effect(\r\n        [\r\n            mainTech,\r\n        ], {},\r\n        []\r\n    );\r\n\r\n    this._mainTech = mainTech;\r\n}\r\ncc.js.extend(LightMaterial, Material);\r\ncc.js.mixin(LightMaterial.prototype, {\r\n    getTexture() {\r\n        return this._texture;\r\n    },\r\n\r\n    setTexture(val) {\r\n        if (this._texture !== val) {\r\n            this._texture = val;\r\n            this._texture.update({\r\n                // Adapt to shader\r\n                flipY: false,\r\n                // For load texture\r\n                mipmap: false\r\n            });\r\n            this.effect.setProperty('iTexture', val.getImpl());\r\n            this._texIds['iTexture'] = val.getId();\r\n        }\r\n    },\r\n    setStrength(s) {\r\n        this.effect.setProperty('light_strength', s);\r\n    },\r\n    setRevert(isRevert) {\r\n        this.effect.setProperty('revert', isRevert);\r\n    },\r\n\r\n});\r\n\r\nmodule.exports = LightMaterial;","let shader = {\r\n    name: 'light',\r\n\r\n    defines: [\r\n\r\n    ],\r\n    vert: `\r\n    uniform mat4 viewProj;\r\n    attribute vec3 a_position;\r\n    attribute vec2 a_uv0;\r\n    varying vec2 uv0;\r\n    void main() {\r\n        vec4 pos = viewProj * vec4(a_position, 1);\r\n        gl_Position = pos;\r\n        uv0 = a_uv0;\r\n    }`,\r\n    frag: `\r\n    uniform float light_strength;\r\n    uniform sampler2D iTexture;\r\n    uniform bool revert;\r\n    varying vec2 uv0;\r\n\r\n    void main()\r\n    {\r\n        vec4 src_color = texture2D(iTexture, uv0).rgba;\r\n        float strength = light_strength;\r\n        vec3 result = vec3(src_color.r * strength, src_color.g * strength, src_color.b * strength);\r\n        gl_FragColor = vec4(result, src_color.a);\r\n    }`,\r\n\r\n};\r\n\r\ncc.game.once(cc.game.EVENT_ENGINE_INITED, function () {\r\n    cc.renderer._forward._programLib.define(shader.name, shader.vert, shader.frag, shader.defines);\r\n});\r\n\r\nmodule.exports = shader;","const math = cc.vmath;\r\nconst renderEngine = cc.renderer.renderEngine;\r\nconst renderer = renderEngine.renderer;\r\nconst gfx = renderEngine.gfx;\r\nconst Material = renderEngine.Material;\r\n\r\n// Require to load the shader to program lib\r\nrequire('RainShader');\r\n\r\nfunction RainMaterial() {\r\n    Material.call(this, false);\r\n\r\n    var pass = new renderer.Pass('rain');\r\n    pass.setDepth(false, false);\r\n    pass.setCullMode(gfx.CULL_NONE);\r\n    pass.setBlend(\r\n        gfx.BLEND_FUNC_ADD,\r\n        gfx.BLEND_SRC_ALPHA, gfx.BLEND_ONE_MINUS_SRC_ALPHA,\r\n        gfx.BLEND_FUNC_ADD,\r\n        gfx.BLEND_SRC_ALPHA, gfx.BLEND_ONE_MINUS_SRC_ALPHA\r\n    );\r\n\r\n    let mainTech = new renderer.Technique(\r\n        ['transparent'],\r\n        [{\r\n                name: 'iTexture',\r\n                type: renderer.PARAM_TEXTURE_2D\r\n            },\r\n            {\r\n                name: 'texSize',\r\n                type: renderer.PARAM_FLOAT2\r\n            },\r\n            {\r\n                name: 'iResolution',\r\n                type: renderer.PARAM_FLOAT3\r\n            },\r\n            {\r\n                name: 'iTime',\r\n                type: renderer.PARAM_FLOAT\r\n            },\r\n        ],\r\n        [\r\n            pass\r\n        ]\r\n    );\r\n\r\n    this._texture = null;\r\n    this._resolution = math.vec3.create();\r\n    this._texSize = math.vec2.create();\r\n    this._time = 0.0;\r\n\r\n    // need _effect to calculate hash\r\n    this._effect = this.effect = new renderer.Effect(\r\n        [\r\n            mainTech,\r\n        ], {\r\n            'iResolution': this._resolution,\r\n            'texSize': this._texSize\r\n        },\r\n        [{\r\n                name: 'HAS_HEART',\r\n                value: true\r\n            },\r\n            {\r\n                name: 'USE_POST_PROCESSING',\r\n                value: true\r\n            }\r\n        ]\r\n    );\r\n\r\n    this._mainTech = mainTech;\r\n}\r\ncc.js.extend(RainMaterial, Material);\r\ncc.js.mixin(RainMaterial.prototype, {\r\n    getTexture() {\r\n        return this._texture;\r\n    },\r\n\r\n    setTexture(val) {\r\n        if (this._texture !== val) {\r\n            this._texture = val;\r\n            this._texture.update({\r\n                // Adapt to shader\r\n                flipY: true,\r\n                // For load texture\r\n                mipmap: true\r\n            });\r\n            this.effect.setProperty('iTexture', val.getImpl());\r\n            this._texIds['iTexture'] = val.getId();\r\n\r\n            this._texSize.x = this._texture.width;\r\n            this._texSize.y = this._texture.height;\r\n        }\r\n    },\r\n\r\n    setResolution(w, h) {\r\n        this._resolution.x = w;\r\n        this._resolution.y = h;\r\n    },\r\n\r\n    setTime(time) {\r\n        this._time = time;\r\n        this.effect.setProperty('iTime', this._time);\r\n    },\r\n\r\n    setHasHeart(value) {\r\n        this.effect.define('HAS_HEART', !!value);\r\n    },\r\n\r\n    usePostProcessing(value) {\r\n        this.effect.define('USE_POST_PROCESSING', !!value);\r\n    }\r\n});\r\n\r\nmodule.exports = RainMaterial;","let shader = {\r\n    name: 'rain',\r\n\r\n    defines: [{\r\n            name: 'HAS_HEART',\r\n        },\r\n        {\r\n            name: 'USE_POST_PROCESSING',\r\n        },\r\n    ],\r\n    vert: `\r\nuniform mat4 viewProj;\r\nuniform mat4 model;\r\nattribute vec3 a_position;\r\nattribute vec2 a_uv0;\r\nvarying vec2 uv0;\r\nvoid main () {\r\n    mat4 mvp;\r\n    mvp = viewProj * model;\r\n\r\n    vec4 pos = mvp * vec4(a_position, 1);\r\n    gl_Position = pos;\r\n    uv0 = a_uv0;\r\n}\r\n`,\r\n    frag: `\r\n// Heartfelt - by Martijn Steinrucken aka BigWings - 2017\r\n// countfrolic@gmail.com\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// I revisited the rain effect I did for another shader. This one is better in multiple ways:\r\n// 1. The glass gets foggy.\r\n// 2. Drops cut trails in the fog on the glass.\r\n// 3. The amount of rain is adjustable (with Mouse.y)\r\n\r\n// To have full control over the rain, uncomment the HAS_HEART define \r\n\r\n// A video of the effect can be found here:\r\n// https://www.youtube.com/watch?v=uiF5Tlw22PI&feature=youtu.be\r\n\r\n// Music - Alone In The Dark - Vadim Kiselev\r\n// https://soundcloud.com/ahmed-gado-1/sad-piano-alone-in-the-dark\r\n// Rain sounds:\r\n// https://soundcloud.com/elirtmusic/sleeping-sound-rain-and-thunder-1-hours\r\n\r\n#define S(a, b, t) smoothstep(a, b, t)\r\n//#define CHEAP_NORMALS\r\n\r\nuniform sampler2D iTexture;\r\nuniform vec3 iResolution;\r\nuniform float iTime;\r\nuniform vec2 texSize;\r\nvarying vec2 uv0;\r\n\r\nvec3 N13(float p) {\r\n    //  from DAVE HOSKINS\r\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\r\n   p3 += dot(p3, p3.yzx + 19.19);\r\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\r\n}\r\n\r\nvec4 N14(float t) {\r\n\treturn fract(sin(t*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\r\n}\r\nfloat N(float t) {\r\n    return fract(sin(t*12345.564)*7658.76);\r\n}\r\n\r\nfloat Saw(float b, float t) {\r\n\treturn S(0., b, t)*S(1., b, t);\r\n}\r\n\r\nvec2 DropLayer2(vec2 uv, float t) {\r\n    vec2 UV = uv;\r\n    \r\n    uv.y += t*0.75;\r\n    vec2 a = vec2(6., 1.);\r\n    vec2 grid = a*2.;\r\n    vec2 id = floor(uv*grid);\r\n    \r\n    float colShift = N(id.x); \r\n    uv.y += colShift;\r\n    \r\n    id = floor(uv*grid);\r\n    vec3 n = N13(id.x*35.2+id.y*2376.1);\r\n    vec2 st = fract(uv*grid)-vec2(.5, 0);\r\n    \r\n    float x = n.x-.5;\r\n    \r\n    float y = UV.y*20.;\r\n    float wiggle = sin(y+sin(y));\r\n    x += wiggle*(.5-abs(x))*(n.z-.5);\r\n    x *= .7;\r\n    float ti = fract(t+n.z);\r\n    y = (Saw(.85, ti)-.5)*.9+.5;\r\n    vec2 p = vec2(x, y);\r\n    \r\n    float d = length((st-p)*a.yx);\r\n    \r\n    float mainDrop = S(.4, .0, d);\r\n    \r\n    float r = sqrt(S(1., y, st.y));\r\n    float cd = abs(st.x-x);\r\n    float trail = S(.23*r, .15*r*r, cd);\r\n    float trailFront = S(-.02, .02, st.y-y);\r\n    trail *= trailFront*r*r;\r\n    \r\n    y = UV.y;\r\n    float trail2 = S(.2*r, .0, cd);\r\n    float droplets = max(0., (sin(y*(1.-y)*120.)-st.y))*trail2*trailFront*n.z;\r\n    y = fract(y*10.)+(st.y-.5);\r\n    float dd = length(st-vec2(x, y));\r\n    droplets = S(.3, 0., dd);\r\n    float m = mainDrop+droplets*r*trailFront;\r\n    \r\n    //m += st.x>a.y*.45 || st.y>a.x*.165 ? 1.2 : 0.;\r\n    return vec2(m, trail);\r\n}\r\n\r\nfloat StaticDrops(vec2 uv, float t) {\r\n\tuv *= 40.;\r\n    \r\n    vec2 id = floor(uv);\r\n    uv = fract(uv)-.5;\r\n    vec3 n = N13(id.x*107.45+id.y*3543.654);\r\n    vec2 p = (n.xy-.5)*.7;\r\n    float d = length(uv-p);\r\n    \r\n    float fade = Saw(.025, fract(t+n.z));\r\n    float c = S(.3, 0., d)*fract(n.z*10.)*fade;\r\n    return c;\r\n}\r\n\r\nvec2 Drops(vec2 uv, float t, float l0, float l1, float l2) {\r\n    float s = StaticDrops(uv, t)*l0; \r\n    vec2 m1 = DropLayer2(uv, t)*l1;\r\n    vec2 m2 = DropLayer2(uv*1.85, t)*l2;\r\n    \r\n    float c = s+m1.x+m2.x;\r\n    c = S(.3, 1., c);\r\n    \r\n    return vec2(c, max(m1.y*l0, m2.y*l1));\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec4 iMouse = vec4(0.0, 0.0, 0.0, 0.0);\r\n    vec2 fragCoord = vec2(uv0.x * texSize.x - 0.5 * texSize.x, 0.5 * texSize.y - uv0.y * texSize.y);\r\n\r\n\tvec2 uv = fragCoord.xy / iResolution.y;\r\n    vec2 UV = (fragCoord.xy+.5*iResolution.xy) / iResolution.xy;\r\n    vec3 M = iMouse.xyz/iResolution.xyz;\r\n    float T = iTime+M.x*2.;\r\n    \r\n    #ifdef HAS_HEART\r\n        T = mod(iTime, 102.);\r\n        T = mix(T, M.x*102., M.z>0.?1.:0.);\r\n    #endif\r\n    \r\n    float t = T*.2;\r\n    \r\n    float rainAmount = iMouse.z>0. ? M.y : sin(T*.05)*.3+.7;\r\n    \r\n    float maxBlur = mix(3., 6., rainAmount);\r\n    float minBlur = 2.;\r\n    \r\n    float story = 0.;\r\n    float heart = 0.;\r\n    \r\n    #ifdef HAS_HEART\r\n        story = S(0., 70., T);\r\n        \r\n        t = min(1., T/70.);\t\t\t\t\t\t// remap drop time so it goes slower when it freezes\r\n        t = 1.-t;\r\n        t = (1.-t*t)*70.;\r\n        \r\n        float zoom= mix(.3, 1.2, story);\t\t// slowly zoom out\r\n        uv *=zoom;\r\n        minBlur = 4.+S(.5, 1., story)*3.;\t\t// more opaque glass towards the end\r\n        maxBlur = 6.+S(.5, 1., story)*1.5;\r\n        \r\n        vec2 hv = uv-vec2(.0, -.1);\t\t\t\t// build heart\r\n        hv.x *= .5;\r\n        float s = S(110., 70., T);\t\t\t\t// heart gets smaller and fades towards the end\r\n        hv.y-=sqrt(abs(hv.x))*.5*s;\r\n        heart = length(hv);\r\n        heart = S(.4*s, .2*s, heart)*s;\r\n        rainAmount = heart;\t\t\t\t\t\t// the rain is where the heart is\r\n        \r\n        maxBlur-=heart;\t\t\t\t\t\t\t// inside the heart slighly less foggy\r\n        uv *= 1.5;\t\t\t\t\t\t\t\t// zoom out a bit more\r\n        t *= .25;\r\n    #else\r\n        float zoom = -cos(T*.2);\r\n        uv *= .7+zoom*.3;\r\n    #endif\r\n    UV = (UV-.5)*(.9+zoom*.1)+.5;\r\n    \r\n    float staticDrops = S(-.5, 1., rainAmount)*2.;\r\n    float layer1 = S(.25, .75, rainAmount);\r\n    float layer2 = S(.0, .5, rainAmount);\r\n    \r\n    vec2 c = Drops(uv, t, staticDrops, layer1, layer2);\r\n    #ifdef CHEAP_NORMALS\r\n    \tvec2 n = vec2(dFdx(c.x), dFdy(c.x));// cheap normals (3x cheaper, but 2 times shittier ;))\r\n    #else\r\n    \tvec2 e = vec2(.001, 0.);\r\n    \tfloat cx = Drops(uv+e, t, staticDrops, layer1, layer2).x;\r\n    \tfloat cy = Drops(uv+e.yx, t, staticDrops, layer1, layer2).x;\r\n    \tvec2 n = vec2(cx-c.x, cy-c.x);\t\t// expensive normals\r\n    #endif\r\n\r\n    #ifdef HAS_HEART\r\n        n *= 1.-S(60., 85., T);\r\n        c.y *= 1.-S(80., 100., T)*.8;\r\n    #endif\r\n\r\n    float focus = mix(maxBlur-c.y, minBlur, S(.1, .2, c.x));\r\n    vec3 col = texture2D(iTexture, UV+n).rgb;\r\n\r\n    #ifdef USE_POST_PROCESSING\r\n        t = (T+3.)*.5;\t\t\t\t\t\t\t\t\t\t// make time sync with first lightnoing\r\n        float colFade = sin(t*.2)*.5+.5+story;\r\n        col *= mix(vec3(1.), vec3(.8, .9, 1.3), colFade);\t// subtle color shift\r\n        float fade = S(0., 10., T);\t\t\t\t\t\t\t// fade in at the start\r\n        float lightning = sin(t*sin(t*10.));\t\t\t\t// lighting flicker\r\n        lightning *= pow(max(0., sin(t+sin(t))), 10.);\t\t// lightning flash\r\n        col *= 1.+lightning*fade*mix(1., .1, story*story);\t// composite lightning\r\n        col *= 1.-dot(UV-=.5, UV);\t\t\t\t\t\t\t// vignette\r\n\r\n        #ifdef HAS_HEART\r\n            col = mix(pow(col, vec3(1.2)), col, heart);\r\n            fade *= S(102., 97., T);\r\n        #endif\r\n\r\n        col *= fade;\t\t\t\t\t\t\t\t\t\t// composite start and end fade\r\n    #endif\r\n\r\n    //col = vec3(heart);\r\n    gl_FragColor = vec4(col, 1.);\r\n}\r\n`,\r\n\r\n};\r\n\r\ncc.game.once(cc.game.EVENT_ENGINE_INITED, function () {\r\n    cc.renderer._forward._programLib.define(shader.name, shader.vert, shader.frag, shader.defines);\r\n});\r\n\r\nmodule.exports = shader;","const math = cc.vmath;\r\nconst renderEngine = cc.renderer.renderEngine;\r\nconst renderer = renderEngine.renderer;\r\nconst gfx = renderEngine.gfx;\r\nconst Material = renderEngine.Material;\r\n\r\n// Require to load the shader to program lib\r\nrequire('./shaping');\r\n\r\nfunction TestMaterial() {\r\n    Material.call(this, false);\r\n\r\n    var pass = new renderer.Pass('test');\r\n    pass.setDepth(false, false);\r\n    pass.setCullMode(gfx.CULL_NONE);\r\n    pass.setBlend(\r\n        gfx.BLEND_FUNC_ADD,\r\n        gfx.BLEND_SRC_ALPHA, gfx.BLEND_ONE_MINUS_SRC_ALPHA,\r\n        gfx.BLEND_FUNC_ADD,\r\n        gfx.BLEND_SRC_ALPHA, gfx.BLEND_ONE_MINUS_SRC_ALPHA\r\n    );\r\n\r\n    let mainTech = new renderer.Technique(\r\n        ['transparent'],\r\n        [{\r\n            name: 'iTexture',\r\n            type: renderer.PARAM_TEXTURE_2D\r\n        }, {\r\n            name: 'iResolution',\r\n            type: renderer.PARAM_FLOAT3\r\n        }, {\r\n            name: 'time',\r\n            type: renderer.PARAM_FLOAT\r\n        }, {\r\n            name: 'u_mouse',\r\n            type: renderer.PARAM_FLOAT2\r\n        }],\r\n        [\r\n            pass\r\n        ]\r\n    );\r\n\r\n    this._texture = null;\r\n    this._resolution = math.vec3.create();\r\n\r\n    // need _effect to calculate hash\r\n    this._effect = this.effect = new renderer.Effect(\r\n        [\r\n            mainTech,\r\n        ], { 'iResolution': this._resolution, },\r\n        []\r\n    );\r\n\r\n    this._mainTech = mainTech;\r\n}\r\ncc.js.extend(TestMaterial, Material);\r\ncc.js.mixin(TestMaterial.prototype, {\r\n    getTexture() {\r\n        return this._texture;\r\n    },\r\n\r\n    setTexture(val) {\r\n        if (this._texture !== val) {\r\n            this._texture = val;\r\n            this._texture.update({\r\n                // Adapt to shader\r\n                flipY: false,\r\n                // For load texture\r\n                mipmap: false\r\n            });\r\n            this.effect.setProperty('iTexture', val.getImpl());\r\n            this._texIds['iTexture'] = val.getId();\r\n        }\r\n    },\r\n\r\n    setTime(time) {\r\n        this.effect.setProperty('time', time);\r\n    },\r\n    setResolution(w, h) {\r\n        cc.log(w, h)\r\n        this._resolution.x = w;\r\n        this._resolution.y = h;\r\n    },\r\n    setPosition(p) {\r\n        let pos = math.vec2.create();\r\n        pos.x = p.x;\r\n        pos.y = p.y;\r\n        this.effect.setProperty('u_mouse', pos);\r\n    }\r\n\r\n\r\n});\r\n\r\nmodule.exports = TestMaterial;","let shader = {\r\n    name: 'test',\r\n\r\n    defines: [\r\n    ],\r\n    vert: `\r\n    uniform mat4 viewProj;\r\n    attribute vec3 a_position;\r\n    attribute vec2 a_uv0;\r\n    varying vec2 uv0;\r\n    void main() {\r\n        vec4 pos = viewProj * vec4(a_position, 1);\r\n        gl_Position = pos;\r\n        uv0 = a_uv0;\r\n    }`,\r\n\r\n    // frag:\r\n    //     `#define TAU 6.12\r\n    //     #define MAX_ITER 10\r\n    //     uniform sampler2D texture;\r\n    //     uniform vec4 color;\r\n    //     uniform float time;\r\n    //     varying vec2 uv0;\r\n\r\n    //     void main()\r\n    //     {\r\n    //         float time = time * .5+5.;\r\n    //         // uv should be the 0-1 uv of texture...\r\n    //         vec2 uv = uv0.xy;//fragCoord.xy / iResolution.xy;\r\n\r\n    //         vec2 p = mod(uv*TAU, TAU)-250.0;\r\n\r\n    //         vec2 i = vec2(p);\r\n    //         float c = 1.0;\r\n    //         float inten = .0045;\r\n\r\n    //         for (int n = 0; n < MAX_ITER; n++) \r\n    //         {\r\n    //             float t =  time * (1.0 - (3.5 / float(n+1)));\r\n    //             i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(1.5*t + i.x));\r\n    //             c += 1.0/length(vec2(p.x / (cos(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\r\n    //         }\r\n    //         c /= float(MAX_ITER);\r\n    //         c = 1.17-pow(c, 1.4);\r\n    //         vec4 tex = texture2D(texture,uv);\r\n    //         vec3 colour = vec3(pow(abs(c), 20.0));\r\n    //         colour = clamp(colour + vec3(0.0, 0.0, .0), 0.0, tex.a);\r\n\r\n    //         // 混合波光\r\n    //         float alpha = c*tex[3];  \r\n    //         tex[0] = tex[0] + colour[0]*alpha; \r\n    //         tex[1] = tex[1] + colour[1]*alpha; \r\n    //         tex[2] = tex[2] + colour[2]*alpha; \r\n    //         gl_FragColor = color * tex;\r\n    //     }`,\r\n\r\n    //渐变亮度的流光\r\n    // frag: `\r\n    // uniform float time;\r\n    // uniform sampler2D iTexture;\r\n    // varying vec2 uv0;\r\n    // uniform vec4 color;\r\n\r\n    // void main()\r\n    // {\r\n    //    vec4 src_color = color * texture2D(iTexture, uv0).rgba;\r\n\r\n    //     float w = 0.4;       //宽度\r\n    //     // float start = tan(time/1.414);  // tan函数  -> 重复\r\n    //     float start = abs(sin(time/1.414)); //sin -> <-往复 \r\n    //     // float start = tan(time/1.414);  \r\n    //     float strength = 3.0;   //流光增亮强度   (调整该值改变流光的增亮强度)\r\n    //     // float strength = 0.08;   //流光增亮强度   (调整该值改变流光的增亮强度)\r\n    //     float offset = 0.2;      //偏移值         (调整该值改变流光的倾斜程度)\r\n    //     if(uv0.x < start &&  uv0.x > (start - w))\r\n    //     // if(uv0.x < (start - offset * uv0.y) &&  uv0.x > (start - offset * uv0.y - w))\r\n    //     {\r\n    //         strength = 1.0 + 2.0 * (1.0-abs(uv0.x - start + w/2.) / (w/2.)); //渐变强度\r\n    //         vec3 result = vec3( src_color.r * strength, src_color.g *strength, src_color.b *strength);\r\n    //         gl_FragColor = vec4(result, src_color.a);\r\n\r\n    //     }else{\r\n    //         gl_FragColor = src_color;\r\n    //     }\r\n    // }`,\r\n\r\n    // 带周期的随机闪电 \r\n    // frag: `\r\n    // uniform float time;\r\n    // uniform sampler2D iTexture;\r\n    // varying vec2 uv0;\r\n    // uniform vec4 color;\r\n\r\n    // // 伪随机\r\n    // float random (float n) {\r\n    //     return fract(sin(n)*1000000.);\r\n    // }\r\n    // float randomPix(float x,float y){\r\n    //     return fract(cos(x * (12.9898) + y * (4.1414)) * 43758.5453);\r\n    // }\r\n    // void main()\r\n    // {\r\n    //    vec4 src_color = color * texture2D(iTexture, uv0).rgba;\r\n    //     float r = 0.5;       //半径\r\n    //     // float start = tan(time/1.414);  // tan函数  -> 重复\r\n    //     // float start = abs(sin(time/1.414)); //sin -> <-往复 \r\n    //     float start = 0.5;  // tan函数  -> 重复\r\n\r\n    //     float shouldStartLight = sin(time);\r\n    //     float rand = random(time);\r\n    //     float strength = 3.0;   //中心亮度增强   (调整该值改变流光的增亮强度)\r\n\r\n    //     float dis = abs(sqrt((uv0.x - start)*(uv0.x - start) + (uv0.y - 0.5)*(uv0.y - 0.5)));\r\n    //     //前 决定连续出现时的间隔  后决定闪电组出现的频率即概率\r\n    //     if(rand>0.85 && shouldStartLight > (rand)){\r\n    //         if(dis<=r)\r\n    //         {\r\n    //             strength = 1. + 3.* (1.-dis/r);\r\n    //             vec3 result = vec3( src_color.r * strength, src_color.g *strength, src_color.b *strength);\r\n    //             gl_FragColor = vec4(result, src_color.a);\r\n    //         }else{\r\n    //             gl_FragColor = src_color;\r\n    //         }\r\n    //     }else{\r\n    //         gl_FragColor = src_color;\r\n    //     }\r\n\r\n    // }`,\r\n\r\n    // rand noise\r\n    // frag: `\r\n    // uniform float time;\r\n    // uniform sampler2D iTexture;\r\n    // varying vec2 uv0;\r\n    // uniform vec4 color;\r\n\r\n    // float random2(vec2 p){\r\n    //     return fract(sin(dot(p.xy,vec2(12.23,78.32)))*232348.23);\r\n    // }\r\n    // float random3(float x,float y){\r\n    //     return fract(cos(x * (time) + y * (time)) * 43758.5453);\r\n    // }\r\n\r\n    // float random (vec2 st) {\r\n    //     return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\r\n    // }\r\n    // // 散列函数（哈希值）\r\n    // float hash(float n) {\r\n    //     return fract(sin(n) * 1e4);\r\n    // }\r\n\r\n    // float hash(vec2 p) { \r\n    //     return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));\r\n    // }\r\n    // float noise(vec2 x) {\r\n    //     vec2 i = floor(x);\r\n    //     vec2 f = fract(x);\r\n\r\n    //     // Four corners in 2D of a tile\r\n    //     float a = hash(i);\r\n    //     float b = hash(i + vec2(1.0, 0.0));\r\n    //     float c = hash(i + vec2(0.0, 1.0));\r\n    //     float d = hash(i + vec2(1.0, 1.0));\r\n\r\n    //     // Simple 2D lerp using smoothstep envelope between the values.\r\n    //     // return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\r\n    //     //\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\r\n    //     //\t\t\tsmoothstep(0.0, 1.0, f.y)));\r\n\r\n    //     // Same code, with the clamps in smoothstep and common subexpressions\r\n    //     // optimized away.\r\n    //     vec2 u = f * f * (3.0 - 2.0 * f);\r\n    //     return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n    // }\r\n\r\n    // void main()\r\n    // {\r\n    //     vec4 src_color = color * texture2D(iTexture, uv0).rgba;\r\n    //     // float start = tan(time/1.414);  // tan函数  -> 重复\r\n    //     // float start = abs(sin(time/1.414)); //sin -> <-往复 \r\n    //     float now = abs(sin(time/1.414));\r\n    //     // vec3 result = vec3( random2(uv0), random2(uv0), random2(uv0));\r\n    //     // vec3 result = vec3( random3(uv0.x,uv0.y), random3(uv0.x,uv0.y), random3(uv0.x,uv0.y));\r\n    //     vec3 result = vec3( noise(uv0), noise(uv0), noise(uv0));\r\n    //     gl_FragColor = vec4(result, src_color.a);\r\n    // }`,\r\n\r\n    //跟随鼠标的眩光效果\r\n    // frag: `\r\n    //     const int NUM_SAMPLES = 60;\r\n    //     uniform float time;\r\n    //     varying vec2 uv0;\r\n    //     uniform sampler2D iTexture;\r\n    //     uniform vec2 u_mouse;  //鼠标位置\r\n\r\n    //     float random (vec2 st) {\r\n    //         return fract(sin(dot(st.xy + fract(time),vec2(12.9898,78.233)))*43758.5453123);\r\n    //     }\r\n    //     float noise(vec2 u){\r\n    //         return mix( mix( random( vec2(0.0,0.0) ),\r\n    //                         random( vec2(1.0,0.0) ), u.x),\r\n    //                     mix( random( vec2(0.0,1.0) ),\r\n    //                         random( vec2(1.0,1.0) ), u.x), u.y);\r\n    //     }\r\n\r\n    //     void main(void) \r\n    //     {\r\n    //         float decay=0.96815;\r\n    //         float exposure=0.21;\r\n    //         float density=0.926;\r\n    //         float weight= 0.9;//0.58767;\r\n\r\n    //         vec2 tc = uv0;\r\n    //         vec2 deltaTexCoord = tc;\r\n\r\n    //         deltaTexCoord =  uv0 + u_mouse - 0.5;//+vec2(sin(time*.7)*.3,-cos(time*.2)*.3)-.5;\r\n    //         deltaTexCoord *= 1.0 / float(NUM_SAMPLES)  * density;\r\n\r\n    //         float illuminationDecay = 1.0;\r\n    //         vec4 color =texture2D(iTexture, tc.xy)*0.305104;\r\n\r\n    //         tc += deltaTexCoord * fract( sin(dot(uv0.xy+fract(time),vec2(12.9898, 78.233)))* 43758.5453 );\r\n\r\n    //         for(int i=0; i < NUM_SAMPLES; i++)\r\n    //         {\r\n    //             tc -= deltaTexCoord;\r\n    //             vec4 sampleTex = texture2D(iTexture, tc)*0.305104;\r\n    //             sampleTex *= illuminationDecay * weight;\r\n    //             color += sampleTex;\r\n    //             illuminationDecay *= decay;\r\n    //         }\r\n    //         gl_FragColor = color*exposure;\r\n    //         // gl_FragColor = vec4( noise(uv0), noise(uv0), noise(uv0), 1.0);\r\n    //     }\r\n    // `\r\n\r\n\r\n    //噪音 烟雾\r\n    // frag:`\r\n    // const vec2 u_resolution = vec2(640,1136);\r\n    // // uniform vec2 u_resolution;\r\n    // uniform vec2 u_mouse;\r\n    // uniform float time;\r\n\r\n    // float random (in vec2 _st) {\r\n    //     return fract(sin(dot(_st.xy,\r\n    //                         vec2(12.9898,78.233)))*\r\n    //         43758.5453123);\r\n    // }\r\n\r\n    // // Based on Morgan McGuire @morgan3d\r\n    // // https://www.shadertoy.com/view/4dS3Wd\r\n    // float noise (in vec2 _st) {\r\n    //     vec2 i = floor(_st);\r\n    //     vec2 f = fract(_st);\r\n\r\n    //     // Four corners in 2D of a tile\r\n    //     float a = random(i);\r\n    //     float b = random(i + vec2(1.0, 0.0));\r\n    //     float c = random(i + vec2(0.0, 1.0));\r\n    //     float d = random(i + vec2(1.0, 1.0));\r\n\r\n    //     vec2 u = f * f * (3.0 - 2.0 * f);\r\n\r\n    //     return mix(a, b, u.x) +\r\n    //             (c - a)* u.y * (1.0 - u.x) +\r\n    //             (d - b) * u.x * u.y;\r\n    // }\r\n\r\n    // #define NUM_OCTAVES 5\r\n\r\n    // float fbm ( in vec2 _st) {\r\n    //     float v = 0.0;\r\n    //     float a = 0.5;\r\n    //     vec2 shift = vec2(100.0);\r\n    //     // Rotate to reduce axial bias\r\n    //     mat2 rot = mat2(cos(0.5), sin(0.5),\r\n    //                     -sin(0.5), cos(0.50));\r\n    //     for (int i = 0; i < NUM_OCTAVES; ++i) {\r\n    //         v += a * noise(_st);\r\n    //         _st = rot * _st * 2.0 + shift;\r\n    //         a *= 0.5;\r\n    //     }\r\n    //     return v;\r\n    // }\r\n\r\n    // void main() {\r\n    //     vec2 st = gl_FragCoord.xy/u_resolution.xy*3.;\r\n    //     // st += st * abs(sin(time*0.1)*3.0);\r\n    //     vec3 color = vec3(0.0);\r\n\r\n    //     vec2 q = vec2(0.);\r\n    //     q.x = fbm( st + 0.00*time);\r\n    //     q.y = fbm( st + vec2(1.0));\r\n\r\n    //     vec2 r = vec2(0.);\r\n    //     r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.15*time );\r\n    //     r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.126*time);\r\n\r\n    //     float f = fbm(st+r);\r\n\r\n    //     color = mix(vec3(0.101961,0.619608,0.666667),\r\n    //                 vec3(0.666667,0.666667,0.498039),\r\n    //                 clamp((f*f)*4.0,0.0,1.0));\r\n\r\n    //     color = mix(color,\r\n    //                 vec3(0,0,0.164706),\r\n    //                 clamp(length(q),0.0,1.0));\r\n\r\n    //     color = mix(color,\r\n    //                 vec3(0.666667,1,1),\r\n    //                 clamp(length(r.x),0.0,1.0));\r\n\r\n    //     gl_FragColor = vec4((f*f*f+.6*f*f+.5*f)*color,1.);\r\n    // }\r\n    // `\r\n    // frag: `\r\n\r\n    // uniform float time;\r\n    // uniform sampler2D iTexture;\r\n    // uniform vec3 iResolution;\r\n    // uniform vec4 color;\r\n    // varying vec2 uv0;\r\n\r\n    // vec3 hsv2rgb (in vec3 hsv) {\r\n    //     hsv.yz = clamp (hsv.yz, 0.0, 1.0);\r\n    //     return hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * 3.14159 * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\r\n    // }\r\n\r\n    // float rand (in vec2 seed) {\r\n    //     return fract (sin (dot (seed, vec2 (12.9898, 78.233))) * 137.5453);\r\n    // }\r\n    // void main(){\r\n    //     vec2 p = gl_FragCoord.xy / iResolution.xy;\r\n    //     vec2 frag = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.y;\r\n    //     frag *= 1.0 - 0.2 * cos (frag.yx) * sin (3.14159 * 0.5 * texture2D (iTexture, vec2 (0.0)).x);\r\n    //     frag *= 5.0;\r\n    //     float random = rand (floor (frag));\r\n    //     vec2 black = smoothstep (1.0, 0.8, cos (frag * 3.14159 * 2.0));\r\n    //     vec3 color = hsv2rgb (vec3 (random, 1.0, 1.0));\r\n    //     color *= black.x * black.y * smoothstep (1.0, 0.0, length (fract (frag) - 0.5));\r\n    //     color *= 0.5 + 0.5 * cos (random + random * time + time + 3.14159 * 0.5 * texture2D (iTexture, vec2 (0.7)).x);\r\n    //     gl_FragColor = vec4 (color, 1.0);\r\n    // }\r\n\r\n    // `\r\n    // frag: `\r\n    // uniform float time;\r\n    // uniform sampler2D iTexture;\r\n    // uniform vec3 iResolution;\r\n    // uniform vec4 color;\r\n    // varying vec2 uv0;\r\n    //         //Calculate the squared length of a vector\r\n    // float length2(vec2 p){\r\n    //     return dot(p,p);\r\n    // }\r\n\r\n    // //Generate some noise to scatter points.\r\n    // float noise(vec2 p){\r\n    //     return fract(sin(fract(sin(p.x) * (43.13311)) + p.y) * 31.0011);\r\n    // }\r\n\r\n    // float worley(vec2 p) {\r\n    //     //Set our distance to infinity\r\n    //     float d = 1e30;\r\n    //     //For the 9 surrounding grid points\r\n    //     for (int xo = -1; xo <= 1; ++xo) {\r\n    //         for (int yo = -1; yo <= 1; ++yo) {\r\n    //             //Floor our vec2 and add an offset to create our point\r\n    //             vec2 tp = floor(p) + vec2(xo, yo);\r\n    //             //Calculate the minimum distance for this grid point\r\n    //             //Mix in the noise value too!\r\n    //             d = min(d, length2(p - tp - noise(tp)));\r\n    //         }\r\n    //     }\r\n    //     return 3.0*exp(-4.0*abs(2.5*d - 1.0));\r\n    // }\r\n\r\n    // float fworley(vec2 p) {\r\n    //     //Stack noise layers \r\n    //     return sqrt(sqrt(sqrt(\r\n    //         worley(p*5.0 + 0.05*time) *\r\n    //         sqrt(worley(p * 50.0 + 0.12 + -0.1*time)) *\r\n    //         sqrt(sqrt(worley(p * -10.0 + 0.03*time))))));\r\n    // }\r\n    // void main(){\r\n    //     vec2 uv = gl_FragCoord.xy / iResolution.xy;\r\n    //     //Calculate an intensity\r\n    //     float t = fworley(uv * iResolution.xy / 1500.0);\r\n    //     //Add some gradient\r\n    //     t*=exp(-length2(abs(0.7*uv - 1.0)));\t\r\n    //     //Make it blue!\r\n    //     gl_FragColor = vec4(t * vec3(0.1, 1.1*t, pow(t, 0.5-t)), 1.0);\r\n    // }\r\n    // `\r\n    //魔性的光晕 来自大佬https://www.shadertoy.com/user/Danguafer \r\n    // frag: `\r\n\r\n    //     uniform float time;\r\n    //     uniform sampler2D iTexture;\r\n    //     uniform vec3 iResolution;\r\n    //     uniform vec4 color;\r\n    //     varying vec2 uv0;\r\n\r\n    //     #define t time\r\n    //     #define r iResolution.xy\r\n    //     void main(){\r\n    //         vec3 c;\r\n    //         float l,z=t;\r\n    //         for(int i=0;i<3;i++) {\r\n    //             vec2 uv,p= uv0;//gl_FragCoord.xy/r;\r\n    //             uv=p;\r\n    //             p-=.5;\r\n    //             p.x*=r.x/r.y;\r\n    //             z+=.07;\r\n    //             l=length(p);\r\n    //             uv+=p/l*(sin(z)+1.)*abs(sin(l*9.-z*2.));\r\n    //             c[i]=.01/length(abs(mod(uv,1.)-.5));\r\n    //         }\r\n    //         gl_FragColor=vec4(c/l,t);\r\n    //     }\r\n\r\n    // `\r\n    frag: `\r\n    // Plot a line on Y using a value between 0.0-1.0\r\n    float plot(vec2 st, float pct){\r\n    return  smoothstep( pct-0.02, pct, st.y) -\r\n            smoothstep( pct, pct+0.02, st.y);\r\n    }\r\n\r\n    `\r\n\r\n};\r\n\r\ncc.game.once(cc.game.EVENT_ENGINE_INITED, function () {\r\n    cc.renderer._forward._programLib.define(shader.name, shader.vert, shader.frag, shader.defines);\r\n});\r\n\r\nmodule.exports = shader;","const math = cc.vmath;\r\nconst renderEngine = cc.renderer.renderEngine;\r\nconst renderer = renderEngine.renderer;\r\nconst gfx = renderEngine.gfx;\r\nconst Material = renderEngine.Material;\r\n\r\n// Require to load the shader to program lib\r\nrequire('./ThunderShader');\r\n\r\nfunction ThunderMaterial() {\r\n    Material.call(this, false);\r\n\r\n    var pass = new renderer.Pass('thunder');\r\n    pass.setDepth(false, false);\r\n    pass.setCullMode(gfx.CULL_NONE);\r\n    pass.setBlend(\r\n        gfx.BLEND_FUNC_ADD,\r\n        gfx.BLEND_SRC_ALPHA, gfx.BLEND_ONE_MINUS_SRC_ALPHA,\r\n        gfx.BLEND_FUNC_ADD,\r\n        gfx.BLEND_SRC_ALPHA, gfx.BLEND_ONE_MINUS_SRC_ALPHA\r\n    );\r\n\r\n    let mainTech = new renderer.Technique(\r\n        ['transparent'],\r\n        [{\r\n            name: 'iTexture',\r\n            type: renderer.PARAM_TEXTURE_2D\r\n        }, {\r\n            name: 'time',\r\n            type: renderer.PARAM_FLOAT\r\n        }],\r\n        [\r\n            pass\r\n        ]\r\n    );\r\n\r\n    this._texture = null;\r\n\r\n    // need _effect to calculate hash\r\n    this._effect = this.effect = new renderer.Effect(\r\n        [\r\n            mainTech,\r\n        ], {},\r\n        []\r\n    );\r\n\r\n    this._mainTech = mainTech;\r\n}\r\ncc.js.extend(ThunderMaterial, Material);\r\ncc.js.mixin(ThunderMaterial.prototype, {\r\n    getTexture() {\r\n        return this._texture;\r\n    },\r\n\r\n    setTexture(val) {\r\n        if (this._texture !== val) {\r\n            this._texture = val;\r\n            this._texture.update({\r\n                // Adapt to shader\r\n                flipY: false,\r\n                // For load texture\r\n                mipmap: false\r\n            });\r\n            this.effect.setProperty('iTexture', val.getImpl());\r\n            this._texIds['iTexture'] = val.getId();\r\n        }\r\n    },\r\n\r\n    setTime(time) {\r\n        this.effect.setProperty('time', time);\r\n    },\r\n\r\n  \r\n\r\n});\r\n\r\nmodule.exports = ThunderMaterial;","let shader = {\r\n    name: 'thunder',\r\n\r\n    defines: [\r\n    ],\r\n    vert: `\r\n    uniform mat4 viewProj;\r\n    attribute vec3 a_position;\r\n    attribute vec2 a_uv0;\r\n    varying vec2 uv0;\r\n    void main() {\r\n        vec4 pos = viewProj * vec4(a_position, 1);\r\n        gl_Position = pos;\r\n        uv0 = a_uv0;\r\n    }`,\r\n\r\n    // frag:\r\n    //     `#define TAU 6.12\r\n    //     #define MAX_ITER 10\r\n    //     uniform sampler2D texture;\r\n    //     uniform vec4 color;\r\n    //     uniform float time;\r\n    //     varying vec2 uv0;\r\n\r\n    //     void main()\r\n    //     {\r\n    //         float time = time * .5+5.;\r\n    //         // uv should be the 0-1 uv of texture...\r\n    //         vec2 uv = uv0.xy;//fragCoord.xy / iResolution.xy;\r\n\r\n    //         vec2 p = mod(uv*TAU, TAU)-250.0;\r\n\r\n    //         vec2 i = vec2(p);\r\n    //         float c = 1.0;\r\n    //         float inten = .0045;\r\n\r\n    //         for (int n = 0; n < MAX_ITER; n++) \r\n    //         {\r\n    //             float t =  time * (1.0 - (3.5 / float(n+1)));\r\n    //             i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(1.5*t + i.x));\r\n    //             c += 1.0/length(vec2(p.x / (cos(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\r\n    //         }\r\n    //         c /= float(MAX_ITER);\r\n    //         c = 1.17-pow(c, 1.4);\r\n    //         vec4 tex = texture2D(texture,uv);\r\n    //         vec3 colour = vec3(pow(abs(c), 20.0));\r\n    //         colour = clamp(colour + vec3(0.0, 0.0, .0), 0.0, tex.a);\r\n\r\n    //         // 混合波光\r\n    //         float alpha = c*tex[3];  \r\n    //         tex[0] = tex[0] + colour[0]*alpha; \r\n    //         tex[1] = tex[1] + colour[1]*alpha; \r\n    //         tex[2] = tex[2] + colour[2]*alpha; \r\n    //         gl_FragColor = color * tex;\r\n    //     }`,\r\n\r\n    //渐变亮度的流光\r\n    // frag: `\r\n    // uniform float time;\r\n    // uniform sampler2D iTexture;\r\n    // varying vec2 uv0;\r\n    // uniform vec4 color;\r\n\r\n    // void main()\r\n    // {\r\n    //    vec4 src_color = color * texture2D(iTexture, uv0).rgba;\r\n\r\n    //     float w = 0.4;       //宽度\r\n    //     // float start = tan(time/1.414);  // tan函数  -> 重复\r\n    //     float start = abs(sin(time/1.414)); //sin -> <-往复 \r\n    //     // float start = tan(time/1.414);  \r\n    //     float strength = 3.0;   //流光增亮强度   (调整该值改变流光的增亮强度)\r\n    //     // float strength = 0.08;   //流光增亮强度   (调整该值改变流光的增亮强度)\r\n    //     float offset = 0.2;      //偏移值         (调整该值改变流光的倾斜程度)\r\n    //     if(uv0.x < start &&  uv0.x > (start - w))\r\n    //     // if(uv0.x < (start - offset * uv0.y) &&  uv0.x > (start - offset * uv0.y - w))\r\n    //     {\r\n    //         strength = 1.0 + 2.0 * (1.0-abs(uv0.x - start + w/2.) / (w/2.)); //渐变强度\r\n    //         vec3 result = vec3( src_color.r * strength, src_color.g *strength, src_color.b *strength);\r\n    //         gl_FragColor = vec4(result, src_color.a);\r\n\r\n    //     }else{\r\n    //         gl_FragColor = src_color;\r\n    //     }\r\n    // }`,\r\n\r\n    // 带周期的随机闪电 \r\n    frag: `\r\n    uniform float time;\r\n    uniform sampler2D iTexture;\r\n    varying vec2 uv0;\r\n    uniform vec4 color;\r\n\r\n    // 伪随机\r\n    float random (float n) {\r\n        return fract(sin(n)*1000000.);\r\n    }\r\n    float randomPix(float x,float y){\r\n        return fract(cos(x * (12.9898) + y * (4.1414)) * 43758.5453);\r\n    }\r\n    void main()\r\n    {\r\n       vec4 src_color = color * texture2D(iTexture, uv0).rgba;\r\n        float r = 0.8;       //半径\r\n        // float start = tan(time/1.414);  // tan函数  -> 重复\r\n        // float start = abs(sin(time/1.414)); //sin -> <-往复 \r\n        float start = 0.5;  // tan函数  -> 重复\r\n\r\n        float shouldStartLight = sin(time);\r\n        float rand = random(time);\r\n        float strength = 3.0;   //中心亮度增强   (调整该值改变流光的增亮强度)\r\n\r\n        float dis = abs(sqrt((uv0.x - start)*(uv0.x - start) + (uv0.y - 0.5)*(uv0.y - 0.5)));\r\n        //前 决定连续出现时的间隔  后决定闪电组出现的频率即概率\r\n        if(rand>0.8 && shouldStartLight > (rand)){\r\n            if(dis<=r)\r\n            {\r\n                strength = 1. + 3.* (1.-dis/r);\r\n                vec3 result = vec3( src_color.r * strength, src_color.g *strength, src_color.b *strength);\r\n                gl_FragColor = vec4(result, src_color.a);\r\n            }else{\r\n                gl_FragColor = src_color;\r\n            }\r\n        }else{\r\n            gl_FragColor = src_color;\r\n        }\r\n\r\n    }`,\r\n\r\n   \r\n};\r\n\r\ncc.game.once(cc.game.EVENT_ENGINE_INITED, function () {\r\n    cc.renderer._forward._programLib.define(shader.name, shader.vert, shader.frag, shader.defines);\r\n});\r\n\r\nmodule.exports = shader;","cc.Class({\r\n    extends: cc.Component,\r\n\r\n    properties: {\r\n        \r\n    },\r\n    start() {\r\n        this._start = Date.now();\r\n        this.target = this.getComponent(cc.Sprite);\r\n        if (this.target && this.target.spriteFrame) {\r\n            let texture = this.target.spriteFrame.getTexture();\r\n            this._material.setTexture(texture);\r\n            this._material.updateHash(Date.now());\r\n            this.target._material = this._material;\r\n            this.target._renderData._material = this._material;\r\n            if (this.autoStart) {\r\n                this._shouldRun = true;\r\n            }\r\n        }\r\n    },\r\n    onLoad: function () {\r\n        cc.dynamicAtlasManager.enabled = false;\r\n        const FluxyMaterial = require('./fluxay/FluxyMaterial');\r\n\r\n        this._material = new FluxyMaterial();\r\n    },\r\n  \r\n   \r\n    update(dt) {\r\n        const now = Date.now();\r\n        let time = ((now - this._start) / 1000);\r\n        // if (time >= 1.414) {\r\n        //     time = 0;\r\n        //     this._start = now;\r\n        // }\r\n        this._material.setTime(time);\r\n    },\r\n});","cc.Class({\r\n    extends: cc.Component,\r\n\r\n    properties: {\r\n        from: 1, //开始亮度 1为原亮度\r\n        to: 3,\r\n        speed: 1,\r\n        breath: true,\r\n        autoStart: false,\r\n        isAnim: true, //是否需要动画\r\n        delay: 1, //非动画方式的延迟回复时间\r\n    },\r\n    start() {\r\n        this.target = this.getComponent(cc.Sprite);\r\n        if (this.target && this.target.spriteFrame) {\r\n            let texture = this.target.spriteFrame.getTexture();\r\n            this._material.setTexture(texture);\r\n            this._material.updateHash(Date.now());\r\n            this.target._material = this._material;\r\n            this.target._renderData._material = this._material;\r\n            if (this.autoStart) {\r\n                this.doStart();\r\n            }\r\n        }\r\n    },\r\n    onLoad: function () {\r\n        this._light = this.from;\r\n\r\n        cc.dynamicAtlasManager.enabled = false;\r\n        const LightMaterial = require('./light/LightMaterial');\r\n\r\n        this._material = new LightMaterial();\r\n    },\r\n    onEnable() {\r\n        // this.startAnim = true;\r\n    },\r\n    doStart() {\r\n        this._light = this.from;\r\n        this._isRunning = true;\r\n        if (this.from > this.to) {\r\n            this._direction = -1;\r\n            this._from = this.to;\r\n            this._to = this.from;\r\n        } else {\r\n            this._direction = 1;\r\n            this._from = this.from;\r\n            this._to = this.to;\r\n        }\r\n        if (!this.isAnim) {\r\n            this._material.setStrength(this.to);\r\n            this.unscheduleAllCallbacks();\r\n            this.scheduleOnce(_ => {\r\n                this._material.setStrength(this.from);\r\n                this._isRunning = false;\r\n            }, this.delay)\r\n        } else {\r\n            this._material.setStrength(this.from);\r\n            this._shouldRun = true;\r\n        }\r\n    },\r\n    doPause() {\r\n\r\n    },\r\n    doResume() {\r\n\r\n    },\r\n    doStop(revert) {\r\n        if (this._shouldRun) {\r\n            this._shouldRun = false;\r\n            this._isRunning = false;\r\n        }\r\n        if (revert) {\r\n            this._material.setStrength(1);\r\n        }\r\n        this._material.setRevert(true);\r\n\r\n    },\r\n    update(dt) {\r\n        if (!this._isRunning) {\r\n            return;\r\n        }\r\n        if (this.target && this.target.spriteFrame && this._material) {\r\n            let texture = this.target.spriteFrame.getTexture();\r\n            this._material.setTexture(texture);\r\n            this.target._material = this._material;\r\n            this.target._renderData._material = this._material;\r\n        }\r\n\r\n        if (!this._shouldRun) {\r\n            return;\r\n        }\r\n        if (this._light >= this._to) {\r\n            this._direction = -1;\r\n        }\r\n        if (this._light <= this._from) {\r\n            this._direction = 1;\r\n        }\r\n        this._light += dt * this.speed * this._direction;\r\n        if ((this._light >= this._to || this._light <= this._from) && !this.breath) {\r\n            this.doStop(false);\r\n        } else {\r\n            this._material.setStrength(this._light);\r\n        }\r\n    },\r\n});","cc.Class({\n    extends: cc.Component,\n\n    properties: {\n       testNode:cc.Node,\n    },\n\n    // use this for initialization\n    onLoad: function () {\n\n        this.scheduleOnce(_ => { \n            this.testNode.active = true;\n        },0.1)\n    },\n\n    // called every frame\n    update: function (dt) {\n\n    },\n});\n","const material = require('./rain/RainMaterial');\r\n\r\ncc.Class({\r\n    extends: cc.Component,\r\n\r\n    properties: {\r\n\r\n    },\r\n    start() {\r\n\r\n        this._start = Date.now();\r\n        this.target = this.getComponent(cc.Sprite);\r\n        if (this.target) {\r\n            let texture = this.target.spriteFrame.getTexture();\r\n            this._material.setTexture(texture);\r\n            this._material.setResolution(this.target.node.width, this.target.node.height);\r\n            this._material.updateHash();\r\n            this.target._material = this._material;\r\n            this.target._renderData._material = this._material;\r\n        }\r\n    },\r\n    onLoad: function () {\r\n        cc.dynamicAtlasManager.enabled = false;\r\n        this._material = new material();\r\n    },\r\n    onEnable() {},\r\n\r\n    update(dt) {\r\n\r\n        let now = Date.now();\r\n        let time = (now - this._start) / 1000;\r\n        this._material.setTime(time);\r\n    },\r\n});","let shader = {\r\n    name: 'test',\r\n\r\n    defines: [\r\n    ],\r\n    vert: `\r\n   \r\n    uniform mat4 viewProj;\r\n    attribute vec3 a_position;\r\n    attribute vec2 a_uv0;\r\n    varying vec2 uv0;\r\n    void main() {\r\n        vec4 pos = viewProj * vec4(a_position, 1);\r\n        gl_Position = pos;\r\n        uv0 = a_uv0;\r\n    }`,\r\n    frag: `\r\n     \r\n    #define PI 3.141592653589793\r\n    #define HALF_PI 1.5707963267948966\r\n    #define TWO_PI 6.28318530718\r\n    // Plot a line on Y using a value between 0.0-1.0\r\n    uniform float time;\r\n    uniform sampler2D iTexture;\r\n    uniform vec3 iResolution;\r\n    uniform vec4 color;\r\n    varying vec2 uv0;\r\n    float plot(vec2 st, float pct){\r\n        return  smoothstep( pct-0.02, pct, 1.-st.y) - smoothstep( pct, pct+0.02, 1.-st.y);\r\n    }\r\n    float linear(float t) {\r\n        return t;\r\n    }\r\n\r\n    float exponentialIn(float t) {\r\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\r\n}\r\n\r\nfloat exponentialOut(float t) {\r\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\r\n}\r\n\r\nfloat exponentialInOut(float t) {\r\n  return t == 0.0 || t == 1.0\r\n    ? t\r\n    : t < 0.5\r\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\r\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\r\n}\r\n\r\nfloat sineIn(float t) {\r\n  return sin((t - 1.0) * HALF_PI) + 1.0;\r\n}\r\n\r\nfloat sineOut(float t) {\r\n  return sin(t * HALF_PI);\r\n}\r\n\r\nfloat sineInOut(float t) {\r\n  return -0.5 * (cos(PI * t) - 1.0);\r\n}\r\n\r\nfloat qinticIn(float t) {\r\n  return pow(t, 5.0);\r\n}\r\n\r\nfloat qinticOut(float t) {\r\n  return 1.0 - (pow(t - 1.0, 5.0));\r\n}\r\n\r\nfloat qinticInOut(float t) {\r\n  return t < 0.5\r\n    ? +16.0 * pow(t, 5.0)\r\n    : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\r\n}\r\n\r\nfloat quarticIn(float t) {\r\n  return pow(t, 4.0);\r\n}\r\n\r\nfloat quarticOut(float t) {\r\n  return pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\r\n}\r\n\r\nfloat quarticInOut(float t) {\r\n  return t < 0.5\r\n    ? +8.0 * pow(t, 4.0)\r\n    : -8.0 * pow(t - 1.0, 4.0) + 1.0;\r\n}\r\n\r\nfloat quadraticInOut(float t) {\r\n  float p = 2.0 * t * t;\r\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\r\n}\r\n\r\nfloat quadraticIn(float t) {\r\n  return t * t;\r\n}\r\n\r\nfloat quadraticOut(float t) {\r\n  return -t * (t - 2.0);\r\n}\r\n\r\nfloat cubicIn(float t) {\r\n  return t * t * t;\r\n}\r\n\r\nfloat cubicOut(float t) {\r\n  float f = t - 1.0;\r\n  return f * f * f + 1.0;\r\n}\r\n\r\nfloat cubicInOut(float t) {\r\n  return t < 0.5\r\n    ? 4.0 * t * t * t\r\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\r\n}\r\n\r\nfloat elasticIn(float t) {\r\n  return sin(13.0 * t * HALF_PI) * pow(2.0, 10.0 * (t - 1.0));\r\n}\r\n\r\nfloat elasticOut(float t) {\r\n  return sin(-13.0 * (t + 1.0) * HALF_PI) * pow(2.0, -10.0 * t) + 1.0;\r\n}\r\n\r\nfloat elasticInOut(float t) {\r\n  return t < 0.5\r\n    ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))\r\n    : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;\r\n}\r\n\r\nfloat circularIn(float t) {\r\n  return 1.0 - sqrt(1.0 - t * t);\r\n}\r\n\r\nfloat circularOut(float t) {\r\n  return sqrt((2.0 - t) * t);\r\n}\r\n\r\nfloat circularInOut(float t) {\r\n  return t < 0.5\r\n    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\r\n    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\r\n}\r\n\r\nfloat bounceOut(float t) {\r\n  const float a = 4.0 / 11.0;\r\n  const float b = 8.0 / 11.0;\r\n  const float c = 9.0 / 10.0;\r\n\r\n  const float ca = 4356.0 / 361.0;\r\n  const float cb = 35442.0 / 1805.0;\r\n  const float cc = 16061.0 / 1805.0;\r\n\r\n  float t2 = t * t;\r\n\r\n  return t < a\r\n    ? 7.5625 * t2\r\n    : t < b\r\n      ? 9.075 * t2 - 9.9 * t + 3.4\r\n      : t < c\r\n        ? ca * t2 - cb * t + cc\r\n        : 10.8 * t * t - 20.52 * t + 10.72;\r\n}\r\n\r\nfloat bounceIn(float t) {\r\n  return 1.0 - bounceOut(1.0 - t);\r\n}\r\n\r\nfloat bounceInOut(float t) {\r\n  return t < 0.5\r\n    ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\r\n    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\r\n}\r\n\r\nfloat backIn(float t) {\r\n  return pow(t, 3.0) - t * sin(t * PI);\r\n}\r\n\r\nfloat backOut(float t) {\r\n  float f = 1.0 - t;\r\n  return 1.0 - (pow(f, 3.0) - f * sin(f * PI));\r\n}\r\n\r\nfloat backInOut(float t) {\r\n  float f = t < 0.5\r\n    ? 2.0 * t\r\n    : 1.0 - (2.0 * t - 1.0);\r\n\r\n  float g = pow(f, 3.0) - f * sin(f * PI);\r\n\r\n  return t < 0.5\r\n    ? 0.5 * g\r\n    : 0.5 * (1.0 - g) + 0.5;\r\n}\r\n\r\n\r\nvec3 rgb2hsb( in vec3 c ){\r\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\r\n    vec4 p = mix(vec4(c.bg, K.wz),\r\n                 vec4(c.gb, K.xy),\r\n                 step(c.b, c.g));\r\n    vec4 q = mix(vec4(p.xyw, c.r),\r\n                 vec4(c.r, p.yzx),\r\n                 step(p.x, c.r));\r\n    float d = q.x - min(q.w, q.y);\r\n    float e = 1.0e-10;\r\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\r\n                d / (q.x + e),\r\n                q.x);\r\n}\r\n\r\n//  Function from Iñigo Quiles\r\n//  https://www.shadertoy.com/view/MsS3Wc\r\nvec3 hsb2rgb( in vec3 c ){\r\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\r\n                             6.0)-3.0)-1.0,\r\n                     0.0,\r\n                     1.0 );\r\n    rgb = rgb*rgb*(3.0-2.0*rgb);\r\n    return c.z * mix(vec3(1.0), rgb, c.y);\r\n}\r\n\r\n    void main(){\r\n        // float y = bounceIn(time + uv0.x);//(uv0.x);\r\n        // vec3 color = vec3(0.,y,y);  //背景色根据函数值调整色值\r\n \r\n        // // Plot a line\r\n        // float pct = plot(uv0,y);\r\n        // //排除线的部分 赋值为背景色\r\n        // color =(1.-pct) * color + pct*vec3(0.0,1.0,0.0);\r\n        //  vec3 color = vec3(0.0);\r\n\r\n        // We map x (0.0 - 1.0) to the hue (0.0 - 1.0)\r\n        // And the y (0.0 - 1.0) to the brightness\r\n        // color = hsb2rgb(vec3(uv0.x,1.0,uv0.y));\r\n\r\n    vec2 st = uv0;//gl_FragCoord.xy/u_resolution;\r\n    // vec3 color = vec3(0.0);\r\n\r\n    // // Use polar coordinates instead of cartesian\r\n    // vec2 toCenter = vec2(0.5)-st;\r\n    // float angle = atan(toCenter.y,toCenter.x);\r\n    // float radius = length(toCenter)*2.0;\r\n\r\n    // // Map the angle (-PI to PI) to the Hue (from 0 to 1)\r\n    // // and the Saturation to the radius\r\n    // color = hsb2rgb(vec3((angle/TWO_PI)+0.5,radius,1.0));\r\n\r\n\r\n    vec3 color = vec3(0.0);\r\n    float left = step(0.1,st.x);   // Similar to ( X greater than 0.1 )\r\n    float bottom = step(0.1,st.y); // Similar to ( Y greater than 0.1 )\r\n\r\n    // The multiplication of left*bottom will be similar to the logical AND.\r\n    color = vec3( left ) * vec3(bottom);\r\n\r\n    gl_FragColor = vec4(color,1.0);\r\n\r\n        gl_FragColor = vec4(color,1.0);\r\n    }\r\n    `\r\n\r\n};\r\n\r\ncc.game.once(cc.game.EVENT_ENGINE_INITED, function () {\r\n    cc.renderer._forward._programLib.define(shader.name, shader.vert, shader.frag, shader.defines);\r\n});\r\n\r\nmodule.exports = shader;","cc.Class({\r\n    extends: cc.Component,\r\n\r\n    properties: {\r\n\r\n    },\r\n    start() {\r\n        this._start = Date.now();\r\n        this.target = this.getComponent(cc.Sprite);\r\n        if (this.target && this.target.spriteFrame) {\r\n            let texture = this.target.spriteFrame.getTexture();\r\n            this._material.setTexture(texture);\r\n            this._material.setResolution(this.target.node.width, this.target.node.height);\r\n            this._material.updateHash(Date.now());\r\n            this.target._material = this._material;\r\n            this.target._renderData._material = this._material;\r\n            if (this.autoStart) {\r\n                this._shouldRun = true;\r\n            }\r\n        }\r\n    },\r\n    onLoad: function () {\r\n        cc.dynamicAtlasManager.enabled = false;\r\n        const material = require('./test/TestMaterial');\r\n\r\n        this._material = new material();\r\n\r\n        this.node.on(cc.Node.EventType.MOUSE_MOVE,e=>{\r\n            let location = this.node.convertToNodeSpaceAR(e.getLocation());\r\n\r\n            this._material.setPosition({\r\n                x:- location.x / (this.node.width),\r\n                y:location.y / (this.node.height),\r\n            })\r\n            \r\n        })\r\n    },\r\n\r\n\r\n    update(dt) {\r\n        const now = Date.now();\r\n        let time = ((now - this._start) / 1000);\r\n        // if (time >= 1.414) {\r\n        //     time = 0;\r\n        //     this._start = now;\r\n        // }\r\n        this._material.setTime(time);\r\n    },\r\n});","cc.Class({\r\n    extends: cc.Component,\r\n\r\n    properties: {\r\n\r\n    },\r\n    start() {\r\n        this._start = Date.now();\r\n        this.target = this.getComponent(cc.Sprite);\r\n        if (this.target && this.target.spriteFrame) {\r\n            let texture = this.target.spriteFrame.getTexture();\r\n            this._material.setTexture(texture);\r\n            this._material.updateHash(Date.now());\r\n            this.target._material = this._material;\r\n            this.target._renderData._material = this._material;\r\n            if (this.autoStart) {\r\n                this._shouldRun = true;\r\n            }\r\n        }\r\n    },\r\n    onLoad: function () {\r\n        cc.dynamicAtlasManager.enabled = false;\r\n        const material = require('./thunder/ThunderMaterial');\r\n\r\n        this._material = new material();\r\n    },\r\n\r\n\r\n    update(dt) {\r\n        const now = Date.now();\r\n        let time = ((now - this._start) / 1000);\r\n        // if (time >= 1.414) {\r\n        //     time = 0;\r\n        //     this._start = now;\r\n        // }\r\n        this._material.setTime(time);\r\n    },\r\n});"],"sourceRoot":"/source/","file":"project.js"}